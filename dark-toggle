#!/bin/sh

# A small POSIX compliant script to toggle between dark and light variant
# of a theme for GNOME based desktops.

# Copyright (C) 2021 Rifaz Nahiyan
# This code is licensed under the MIT License.
# View the license in its entirety at: https://opensource.org/licenses/MIT

# Get the script's basename and trim the '.sh' (if any) at the end
SCRIPTNAME="${0##*/}"
SCRIPTNAME="${SCRIPTNAME%.sh}"
USER_CONFIG="$HOME/.config/dark-toggle/config"
SYS_CONFIG="/etc/dark-toggle/config"

variant_found=
warnings=

get_current_theme () {
    gsettings get org.gnome.desktop.interface gtk-theme | tr --delete \'
}

set_theme () {
    gsettings set org.gnome.desktop.interface gtk-theme "$1"
    # Unfortunately, gsettings always reports exit status 0
}

strstr () {
    # Check if $2 is strstr of $1
    # https://www.shellscript.sh/tips/strstr/
    [ "${1#*$2*}" = "$1" ] && return 1
    return 0
}

# Display a formatted message, then exit with error
die () {
	printf "%s: %s\n" "${0##*/}" "${*}" >&2
	exit 1
}

print_warnings () {
    IFS=:
    printf "%s: errors while parsing the config file.\n" "${SCIPTNAME}" >&2
    printf "  - %s\n" $* >&2
    unset IFS
}

## Sanity checks
deps_check () {
	deps="gsettings notify-send"
	missing=""
	for dep in ${deps}; do
		command -v "${dep}" >/dev/null || missing="${missing} ${dep}"
	done
	if [ -n "${missing}" ]
	then
		die "Missing necessary dependencies: ${missing}"
	fi
	unset missing
}

theme_check () {
    local user_theme="$HOME/.themes/$1"
    local system_theme="/usr/share/themes/$1"
    [ -f "$user_theme/gtk-3.0/gtk.css" ] || [ -f "$system_theme/gtk-3.0/gtk.css" ]
}

# Config file sanity checks
config_exists () {
    local conf="$1"
    [ -f "$conf" ]
}

config_valid () {
    # Checks whether all lines in config are sytactically valid
    local conf="$1"
    local conf_errors=

    while read line; do
        # Remove white space from line before processing
        line="$(printf "$line" | tr --delete '[[:space:]]')"

        case "$line" in
            theme_mappings=*)
                # Trim 'key=' part from $line
                line="${line#*=}"

                # Now the line should be surrounded by double quotes 
                quotes="${line:0:1}${line: -1}"
                [ "$quotes" != '""' ] && conf_errors="${conf_errors}Missing/mismatched quotes in config.:"

                # Check if every theme has a corresponding alternative theme specified
                { strstr "$line" '*:[,"]' || strstr "$line" '[",]:*'; } && conf_errors="${conf_errors}One or more theme pairs is missing a corresponding value.:"
                ;;

            fallback_dark_theme=*|fallback_light_theme=*)
                continue ;;

            *=*)
                local invalid_key="${line%=*}"
                conf_errors="${conf_errors}Invalid key ($invalid_key) assignment.:"
                ;;

            \#*|"") continue ;;

            *) conf_errors="${conf_errors}Invalid indentifier exists. Only key assignments (key=...) and comments (#) are supported.:" ;;
        esac
    done < "$conf"

    [ -n "$conf_errors" ] && { print_warnings "$conf_errors"; return 1; }

    return 0
}

config_parsable () {
    # Shortcut function for checking whether config file exists and is valid
    local conf_file="$1"
    if [ -f "$conf_file" ] && config_valid "$conf_file"; then
        return 0
    fi

    return 1
}

custom_theme_mapping_exists () {
    # Check whether a mapping in config file exists for theme_name
    local conf_file="$1"
    local theme_name="$2"
    local mapping_exists=1 # Initialized as false

    while read line; do
        line="$(printf "$line" | tr --delete '[[:space:]]')"

        case $line in
            theme_mappings=*)
                { strstr "$line" "$theme_name:" || strstr "$line" ":$theme_name"; } \
                    && mapping_exists=0
                ;;
        esac
    done < "$conf_file"

    return $mapping_exists
}

## Config parsing
get_theme_from_config () {
    local conf_file="$1"
    local new_theme=

    while read line; do
        # line="${line//[ \"]/}"
        line="$(printf "$line" | tr --d '[[:space:]]' | tr -d '""')"

        case $line in
            theme_mappings=*)
                line="${line#theme_mappings=}"
                IFS=,
                for pair in $line; do
                    IFS=: read left right <<< "$pair"
                    [ "$left" = "$current_theme" ] && new_theme="$right"
                    [ "$right" = "$current_theme" ] && new_theme="$left"
                done
                unset IFS

				;;
        esac
    done < "$conf_file"

    printf "%s\n" "$new_theme"
}

main () {
    # Check if necessary and optional dependecies are there, else exit
    deps_check
    current_theme="$(get_current_theme)"

    # new_theme="config"

    # Check if the theme name has "dark" or "Dark" at the end of its name,
    # then try the following in order:
    # 1. Try removing the -[Dd]ark part
    # 2. Replace -[Dd]ark with -Light
    # 3. Replace -[Dd]ark with -light
    # Try the same logic for themes having [Ll]ight in the end of their name.
    [ -z "$new_theme" ] && case $current_theme in
        *[dD]ark)
            new_theme="${current_theme%-[Dd]ark}"

            if ! theme_check "$new_theme"
            then
                new_theme="${new_theme}-Light"
            fi

            if ! theme_check "$new_theme"
            then
                new_theme="${new_theme}-light"
            fi
            ;;

        *[lL]ight)
            # new_theme="${current_theme//[lL]ight/Dark}"
            new_theme="${current_theme%[lL]ight}Dark"
            theme_check "$new_theme" || new_theme="${new_theme%Dark}dark"
            DARK=dark
            ;;

        *)
            new_theme="$current_theme"-dark
            theme_check "$new_theme" || new_theme="$current_theme"-Dark
            DARK=dark
            ;;
    esac

    theme_check "$new_theme" || die "The theme is not installed: ${new_theme}"
    set_theme "$new_theme"
    notify_msg="Theme switched to ${DARK:-light} variant."
    notify-send -t 5000 "${SCRIPTNAME}" "$notify_msg"
}

main "${@}"

